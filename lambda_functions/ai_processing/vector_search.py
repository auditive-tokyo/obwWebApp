import openai
import json
from typing import Optional
from utils.system_instructions import get_vector_search_instructions


def _create_error_response(message: str, response_id: str = None) -> str:
    """エラーレスポンスのJSON文字列を生成"""
    return json.dumps({
        "assistant_response_text": message,
        "needs_operator": False,
        "end_conversation": False,
        "response_id": response_id
    }, ensure_ascii=False)


def _get_response_format_schema() -> dict:
    """レスポンスフォーマットのスキーマを取得"""
    return {
        "type": "object",
        "properties": {
            "assistant_response_text": {
                "type": "string",
                "description": "The final text response generated by the assistant based on the file search results or lack thereof."
            },
            "needs_operator": {
                "type": "boolean",
                "description": "True if the user explicitly states a need to speak with an operator, false otherwise. Defaults to false in this initial search phase."
            },
            "end_conversation": {
                "type": "boolean",
                "description": "True if the user indicates they have no further inquiries and wants to end the call, false otherwise. Defaults to false."
            }
        },
        "required": ["assistant_response_text", "needs_operator", "end_conversation"],
        "additionalProperties": False
    }


def _build_request_payload(system_instructions: str, query_text: str, vector_store_id: str, previous_response_id: str = None) -> dict:
    """APIリクエストペイロードを構築"""
    payload = {
        "model": "gpt-5-mini",
        "instructions": system_instructions,
        "input": [{"role": "user", "content": query_text}],
        "tools": [
            {
                "type": "file_search",
                "vector_store_ids": [vector_store_id],
                "max_num_results": 10,
                "ranking_options": {"score_threshold": 0.2}
            }
        ],
        "reasoning": {
            "effort": "low"
        },
        "tool_choice": "auto",
        "text": {
            "verbosity": "low",
            "format": {
                "type": "json_schema",
                "name": "AssistantResponseWithOperatorFlag",
                "schema": _get_response_format_schema(),
                "strict": True
            }
        }
    }
    if previous_response_id:
        payload["previous_response_id"] = previous_response_id
    return payload


def _extract_response_id(response) -> Optional[str]:
    """レスポンスからIDを抽出"""
    if response and hasattr(response, 'id'):
        print(f"Response ID: {response.id}")
        return response.id
    print("Warning: Could not retrieve response ID from API response.")
    return None


def _find_output_message(response) -> Optional[object]:
    """レスポンスからoutput messageを探す"""
    if not response or not hasattr(response, 'output'):
        print("Error: Response object or response.output is missing.")
        return None
    
    if not isinstance(response.output, list) or len(response.output) == 0:
        print(f"Error: response.output is not a list or is empty: {response.output}")
        return None
    
    return next(
        (item for item in reversed(response.output) if hasattr(item, 'type') and item.type == 'message'),
        None
    )


def _extract_output_text(output_message) -> Optional[str]:
    """output messageからテキストを抽出"""
    if not output_message:
        return None
    
    if not hasattr(output_message, 'content') or not isinstance(output_message.content, list) or len(output_message.content) == 0:
        print("Error: Could not find valid ResponseOutputMessage content.")
        return None
    
    output_text_obj = output_message.content[0]
    if not hasattr(output_text_obj, 'type') or output_text_obj.type != 'output_text':
        print(f"Error: Expected ResponseOutputText, but got: {output_text_obj}")
        return None
    
    if hasattr(output_text_obj, 'text') and isinstance(output_text_obj.text, str):
        return output_text_obj.text
    
    return None


def _parse_model_output(text: str) -> dict:
    """モデル出力のJSONをパース"""
    try:
        data = json.loads(text)
        return {
            "assistant_response_text": data.get("assistant_response_text", "Error: 'assistant_response_text' key missing."),
            "needs_operator": data.get("needs_operator", False),
            "end_conversation": data.get("end_conversation", False)
        }
    except json.JSONDecodeError:
        print(f"Error: Failed to parse JSON from model output: {text}")
        return {
            "assistant_response_text": "検索結果に基づく応答の抽出に失敗しました。",
            "needs_operator": False,
            "end_conversation": False
        }


def _extract_final_output(response, response_id: str) -> dict:
    """レスポンスから最終出力を抽出"""
    default_output = {
        "assistant_response_text": "検索結果に基づく応答の抽出に失敗しました。",
        "needs_operator": False,
        "end_conversation": False,
        "response_id": response_id
    }
    
    output_message = _find_output_message(response)
    if not output_message:
        return default_output
    
    text = _extract_output_text(output_message)
    if not text:
        return default_output
    
    parsed = _parse_model_output(text)
    parsed["response_id"] = response_id
    return parsed


def _handle_api_status_error(e: openai.APIStatusError) -> str:
    """APIStatusErrorの詳細をログ出力してエラーレスポンスを返す"""
    error_details_str = "N/A"
    try:
        error_details_json = e.response.json()
        error_details_str = json.dumps(error_details_json, indent=2, ensure_ascii=False)
    except json.JSONDecodeError:
        error_details_str = e.response.text
    except Exception as ex_detail:
        error_details_str = f"エラー詳細の取得中に別のエラーが発生: {ex_detail}"
    
    print(f"OpenAI APIステータスエラー (HTTP {e.status_code}): {e.response}")
    print(f"エラー詳細:\n{error_details_str}")
    return _create_error_response("データベース検索中に予期せぬエラーが発生しました。管理者にご連絡ください。")


async def openai_vector_search_with_file_search_tool(
    openai_async_client: openai.AsyncOpenAI,
    query_text: str,
    language: str,
    vector_store_id: str = None,
    previous_response_id: str = None,
    guest_info: dict = None
) -> str:
    
    print(f"Previous Response ID: {previous_response_id}")
    
    # ゲスト情報をログ出力
    if guest_info:
        print(f"Guest info in vector_search: {json.dumps(guest_info, ensure_ascii=False)}")
    else:
        print("No guest info provided to vector_search")

    # バリデーション
    if not openai_async_client:
        print("Error: OpenAI async client not provided.")
        return _create_error_response("エラー: OpenAIクライアントが利用できません。")
    
    if not vector_store_id:
        print("Error: Vector Store ID not provided or configured.")
        return _create_error_response("エラー: 検索対象のデータベースが設定されていません。")

    print(f"File Search Tool を使用して検索開始: '{query_text}' (Vector Store: {vector_store_id})")

    system_instructions = get_vector_search_instructions(guest_info, language)
    
    try:
        request_payload = _build_request_payload(system_instructions, query_text, vector_store_id, previous_response_id)
        response = await openai_async_client.responses.create(**request_payload)

        print("--- OpenAI API Response (Success with JSON Schema) ---")
        response_id = _extract_response_id(response)
        print("--- End of OpenAI API Response ---")

        final_output = _extract_final_output(response, response_id)
        generated_json_string = json.dumps(final_output, ensure_ascii=False)
        print(f"File Search Tool による応答生成完了。最終JSON文字列: {generated_json_string}")
        return generated_json_string

    except openai.APIConnectionError as e:
        print(f"OpenAI APIへの接続エラー: {e}")
        return _create_error_response("申し訳ありません、現在データベースへの接続に問題が発生しています。")
    except openai.RateLimitError as e:
        print(f"OpenAI APIレート制限エラー: {e}")
        return _create_error_response("現在、多くのお問い合わせを処理中です。恐れ入りますが、少し時間をおいて再度お試しください。")
    except openai.APIStatusError as e:
        return _handle_api_status_error(e)
    except Exception as e:
        print(f"File Search Tool 処理中に予期せぬエラーが発生しました: {e}")
        return _create_error_response(f"「{query_text}」の検索中にエラーが発生しました。")
